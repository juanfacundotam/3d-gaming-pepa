<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js + Cannon-es con Joystick suave</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }

    /* Joystick styles */
    #joystick {
      position: absolute;
      bottom: 35px;
      width: 80px;
      height: 80px;
      background: rgba(126, 126, 126, 0.5);
      border: #444 solid medium;
      border-radius: 50%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      touch-action: none;
      user-select: none;
    }

    #thumb {
      position: absolute;
      left: 20px;
      top: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #fff;
    }

    #gameOverText {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: red;
      /* Color rojo para el texto */
      font-size: 5em;
      /* Tamaño grande para que sea visible */
      font-family: Arial, sans-serif;
      /* Fuente legible */
      font-weight: bold;
      /* Negrita */
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
      /* Sombra para mejor visibilidad */
      z-index: 100;
      /* Asegura que esté por encima de todo */
      pointer-events: none;
      /* Permite que los clics pasen a través del texto si es necesario */
    }
  </style>
</head>

<body>
  <div id="joystick">
    <div id="thumb"></div>
  </div>

  <div id="gameOverText" style="display: none">GAME OVER</div>
  <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/",
          "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
        }
      }
    </script>

  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
    import * as CANNON from "cannon-es";

    // --- Setup Three.js ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    // Puedes inicializarla aquí con una posición cercana a la esperada del avión,
    // o dejarla en (0,0,0) y que la lógica del `if` en animate la actualice en el primer frame.
    camera.position.set(0, 1.6, 3);
    const cameraOffset = new THREE.Vector3(0, 2.5, 4); // Se crea una sola vez



    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Luces
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 7.5);
    scene.add(light);

    const ambient = new THREE.AmbientLight(0x404040);
    scene.add(ambient);

    // --- Setup Cannon-es (físicas) ---
    const world = new CANNON.World();
    world.gravity.set(0, -9, 0);

    const defaultMaterial = new CANNON.Material("default");
    const airplanePhysicsMaterial = new CANNON.Material("airplaneMaterial");
    const floorMaterial = new CANNON.Material("floorMaterial"); // <--- Nuevo material para el suelo




    const airplaneObstacleContactMaterial = new CANNON.ContactMaterial(
      airplanePhysicsMaterial,
      defaultMaterial, // Para colisiones con obstáculos generales
      {
        friction: 0.1,
        restitution: 0.1,
      }
    );
    world.addContactMaterial(airplaneObstacleContactMaterial);

    // Nuevo ContactMaterial para la colisión entre el avión y el suelo
    const airplaneFloorContactMaterial = new CANNON.ContactMaterial(
      airplanePhysicsMaterial,
      floorMaterial, // Para colisiones con el suelo
      {
        friction: 0, // Puedes ajustar la fricción para que el robot no patine tanto
        restitution: 0.0, // Que no rebote en el suelo
      }
    );
    world.addContactMaterial(airplaneFloorContactMaterial); // ¡No olvides añadirlo al mundo!
    world.addContactMaterial(airplaneObstacleContactMaterial);


    let airplaneModel;
    let airplaneBody;
    let mixer = null;
    let action1, actionRotate;
    let gameOver = false;

    // Material para el avión para controlar fricción


    // Loaders
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath(
      "https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/libs/draco/gltf/"
    );
    dracoLoader.setDecoderConfig({ type: "js" });

    const loader = new GLTFLoader();
    loader.setDRACOLoader(dracoLoader);


    loader.load(
      "robot.glb",
      (gltf) => {
        airplaneModel = gltf.scene;
        airplaneModel.position.set(1.3, 2.24, 0);
        airplaneModel.scale.set(0.3, 0.3, 0.3); // explícito y claro
        // deberías ver valores ≠ 0

        scene.add(airplaneModel);

        const boxShape = new CANNON.Box(new CANNON.Vec3(0.5, 0, 1));
        airplaneBody = new CANNON.Body({
          mass: 1,
          shape: boxShape,
          material: airplanePhysicsMaterial,
          position: new CANNON.Vec3(
            airplaneModel.position.x,
            airplaneModel.position.y,
            airplaneModel.position.z
          ),
          linearDamping: 0.95, // Se mantiene el damping lineal
          angularDamping: 0.95, // <--- Este damping es crucial para que el giro se detenga
        });
        world.addBody(airplaneBody);

        console.log("¡Modelo de avión y cuerpo físico cargados!");

        if (gltf.animations && gltf.animations.length > 1) {
          mixer = new THREE.AnimationMixer(airplaneModel);
          actionRotate = mixer.clipAction(gltf.animations[0]);
          actionRotate.loop = THREE.LoopRepeat;
          actionRotate.clampWhenFinished = true;
          actionRotate.enabled = true;

          actionRotate.time = 2.475;
          actionRotate.play();
          actionRotate.paused = true;

          action1 = mixer.clipAction(gltf.animations[6]);
          action1.loop = THREE.LoopRepeat;
          action1.enabled = true;
          action1.play();
        }
      },
      undefined,
      (error) => {
        console.error("Error al cargar el modelo GLTF de avión:", error);
      }
    );

    loader.load(
      "escena.glb",
      (gltf) => {
        const sceneModel = gltf.scene;
        console.log(sceneModel);
        scene.add(sceneModel);

        sceneModel.traverse((child) => {
          // Modifica esta parte
          if (child.isMesh && (child.name.startsWith("colision") || child.name === "calle")) {
            child.geometry.computeBoundingBox();
            const size = new THREE.Vector3();
            child.geometry.boundingBox.getSize(size);

            const obstacleShape = new CANNON.Box(
              new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2)
            );

            let bodyMaterial;
            if (child.name === "calle") {
              bodyMaterial = floorMaterial; // Asigna el material del suelo
            } else {
              bodyMaterial = defaultMaterial; // Los demás obstáculos usan el material por defecto
            }

            const obstacleBody = new CANNON.Body({
              mass: 0,
              shape: obstacleShape,
              material: bodyMaterial, // <--- Usa el material determinado
              position: new CANNON.Vec3(
                child.getWorldPosition(new THREE.Vector3()).x,
                child.getWorldPosition(new THREE.Vector3()).y,
                child.getWorldPosition(new THREE.Vector3()).z
              ),
            });
            world.addBody(obstacleBody);

            console.log(`Cuerpo físico estático creado para: ${child.name}`);
          }
        });

        console.log(
          "Modelo de escena y cuerpos físicos estáticos de Cannon.js cargados."
        );
      },
      undefined,
      (error) => {
        console.error("Error al cargar el modelo GLTF de escena:", error);
      }
    );

    // world.addEventListener("beginContact", (event) => {
    //   const bodyA = event.bodyA;
    //   const bodyB = event.bodyB;

    //   if (
    //     (bodyA === airplaneBody && bodyB.mass === 0) ||
    //     (bodyB === airplaneBody && bodyA.mass === 0)
    //   ) {
    //     console.log("¡COLISIÓN DETECTADA POR CANNON.JS!");
    //     if (!gameOver) {
    //       gameOver = true;
    //       const gameOverText = document.getElementById("gameOverText");
    //       gameOverText.style.display = "block";

    //       if (mixer) {
    //         mixer.timeScale = 0;
    //       }
    //       joystickInput.strafe = 0;
    //       joystickInput.forward = 0;
    //       if (airplaneBody) {
    //         airplaneBody.velocity.set(0, 0, 0);
    //         airplaneBody.angularVelocity.set(0, 0, 0);
    //       }
    //     }
    //   }
    // });
    world.addEventListener("beginContact", (event) => {
      const bodyA = event.bodyA;
      const bodyB = event.bodyB;

      // Accede a los materiales de los cuerpos directamente del evento de contacto
      const materialA = bodyA.material;
      const materialB = bodyB.material;

      // Identifica si uno de los cuerpos es el avión y el otro es un cuerpo estático
      const isAirplaneA = bodyA === airplaneBody;
      const isAirplaneB = bodyB === airplaneBody;

      // Verifica si el avión colisionó con un obstáculo (usando defaultMaterial)
      const collidedWithObstacle =
        (isAirplaneA && materialB === defaultMaterial) ||
        (isAirplaneB && materialA === defaultMaterial);

      // Verifica si el avión colisionó con el suelo (usando floorMaterial)
      const collidedWithFloor =
        (isAirplaneA && materialB === floorMaterial) ||
        (isAirplaneB && materialA === floorMaterial);

      if (collidedWithObstacle) {
        console.log("¡COLISIÓN CON OBSTÁCULO DETECTADA! GAME OVER.");
        if (!gameOver) {
          gameOver = true;
          const gameOverText = document.getElementById("gameOverText");
          gameOverText.style.display = "block";

          if (mixer) {
            mixer.timeScale = 0; // Detiene las animaciones del robot
          }
          joystickInput.strafe = 0;
          joystickInput.forward = 0;
          if (airplaneBody) {
            airplaneBody.velocity.set(0, 0, 0); // Detiene el movimiento del robot
            airplaneBody.angularVelocity.set(0, 0, 0);
          }
        }
      } else if (collidedWithFloor) {
        console.log("Colisión con el suelo (calle)");
        // Aquí puedes añadir lógica si quieres que pase algo al tocar el suelo
        // por ejemplo, reducir un poco la velocidad si está en el aire y aterriza, etc.
      }
    });

    // --- Control teclado ---
    const keys = {};
    window.addEventListener(
      "keydown",
      (e) => (keys[e.key.toLowerCase()] = true)
    );
    window.addEventListener(
      "keyup",
      (e) => (keys[e.key.toLowerCase()] = false)
    );



    // Variable global o en ámbito donde se mantenga entre frames
    let smoothedStrafe = 0;
    const threshold = 0.5; // Ajustá a lo que te guste

    function updateAnimationWithJoystick(strafe, action, deltaTime) {
      if (!action) return;

      const leftTime = 1.4;
      const rightTime = 3.65;
      // const centerTime = 2.475;

      const turnSpeed = 3;
      const returnSpeed = 5;

      // Si el strafe está dentro del umbral, tratarlo como 0

      if (Math.abs(strafe) < threshold) {
        strafe = 0;
      }

      const isReturning = Math.abs(strafe) < Math.abs(smoothedStrafe);
      const smoothingSpeed = isReturning ? returnSpeed : turnSpeed;

      smoothedStrafe +=
        (strafe - smoothedStrafe) * deltaTime * smoothingSpeed;

      // Normalización lineal (de -1 a 1) a tiempos
      const normalized = (smoothedStrafe + 1) / 2; // -1 → 0, 1 → 1
      const targetTime = leftTime + normalized * (rightTime - leftTime);

      if (!action.isRunning()) action.play();
      action.paused = true;

      action.time += (targetTime - action.time) * deltaTime * 5;
      action.setEffectiveWeight(1);
    }

    // --- Animación y física ---
    const clock = new THREE.Clock();


    const movementSpeed = 50; // Velocidad lineal máxima
    const rotationSpeed = 2; // Velocidad angular máxima para el giro

    //   const animStart = 1; // segundo inicio animación
    //   const animEnd = 5; // segundo fin animación
    //   let joystickActive = false;
    let strafeValue = 0;
    const fixedTimeStep = 1.0 / 60.0;
    const maxSubSteps = 3;

    const tempLocalForce = new CANNON.Vec3();
    const tempGlobalTorque = new CANNON.Vec3();
    const smoothedCameraPosition = new THREE.Vector3();
    function animate() {
      requestAnimationFrame(animate);

      const deltaTime = clock.getDelta();

      if (gameOver) {
        if (mixer) {
          mixer.update(deltaTime);
        }
        renderer.render(scene, camera);
        return;
      }

      if (airplaneBody) {
        // Coeficiente de resistencia aerodinámica (ajusta este valor)
        const arrastreCoefficient = 0.1;

        // Velocidad actual
        const velocity = airplaneBody.velocity;

        // Fuerza de arrastre = -velocidad * coeficiente
        const dragForce = velocity.scale(-arrastreCoefficient);

        // Aplica la fuerza de arrastre en el centro de masa
        airplaneBody.applyForce(dragForce, new CANNON.Vec3(0, 0, 0));
      }


      // Actualizar físicas
      world.step(fixedTimeStep, deltaTime, maxSubSteps);



      if (airplaneModel && airplaneBody) {
const maxRotation = 0.5;
const strafe = joystickInput.strafe;

// Movimiento del cuerpo físico (lo tuyo)
const maxLateralOffset = 4;
const lateralSpeed = 3;
const currentX = airplaneBody.position.x;

airplaneBody.velocity.z = -2;

if (strafe < 0 && currentX > -maxLateralOffset) {
  airplaneBody.velocity.x = -lateralSpeed;
} else if (strafe > 0 && currentX < maxLateralOffset) {
  airplaneBody.velocity.x = lateralSpeed;
} else {
  airplaneBody.velocity.x = 0;
}

// Copiar posición y rotación física al modelo visual
airplaneModel.position.copy(airplaneBody.position);
airplaneModel.quaternion.copy(airplaneBody.quaternion);

// Convertir la rotación física a Euler para editar la rotación Y (inclinación)
const euler = new THREE.Euler().setFromQuaternion(airplaneModel.quaternion);

// Aplicar la rotación extra en Y (inclinación por strafe)
euler.y += maxRotation * strafe;

// Actualizar la rotación del modelo con la rotación compuesta
airplaneModel.quaternion.setFromEuler(euler);

// El resto de tu código sigue igual:
const antiGravity = new CANNON.Vec3(
  0,
  -world.gravity.y * airplaneBody.mass,
  0
);
airplaneBody.applyLocalForce(antiGravity, new CANNON.Vec3(0, 0, 0));

const relativeCameraOffset = cameraOffset.clone().applyQuaternion(airplaneModel.quaternion);
const targetCameraPos = airplaneModel.position.clone().add(relativeCameraOffset);

camera.position.copy(targetCameraPos);

const lookAtTarget = airplaneModel.position.clone();
lookAtTarget.y -= -1.2;

camera.lookAt(lookAtTarget);
      }

      updateAnimationWithJoystick(
        joystickInput.strafe,
        actionRotate,
        deltaTime
      );

      if (mixer) {
        mixer.update(deltaTime);
      }

      // controls.update();
      renderer.render(scene, camera);
    }

    window.onload = animate;

    // --- Ajuste de ventana ---
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
  <script src="./joystick.js"></script>
</body>

</html>