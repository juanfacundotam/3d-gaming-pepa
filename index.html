<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Three.js + Cannon-es con Joystick suave</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      display: block;
    }

    /* Joystick styles */
    #joystick {
      position: absolute;
      bottom: 35px;
      width: 80px;
      height: 80px;
      background: rgba(126, 126, 126, 0.5);
      border: #444 solid medium;
      border-radius: 50%;
      left: 50%;
      transform: translateX(-50%);
      z-index: 10;
      touch-action: none;
      user-select: none;
    }

    #thumb {
      position: absolute;
      left: 20px;
      top: 20px;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: #fff;
    }

    #gameOverText {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: red;
      /* Color rojo para el texto */
      font-size: 5em;
      /* Tamaño grande para que sea visible */
      font-family: Arial, sans-serif;
      /* Fuente legible */
      font-weight: bold;
      /* Negrita */
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.7);
      /* Sombra para mejor visibilidad */
      z-index: 100;
      /* Asegura que esté por encima de todo */
      pointer-events: none;
      /* Permite que los clics pasen a través del texto si es necesario */
    }
  </style>
</head>

<body>
  <div id="joystick">
    <div id="thumb"></div>
  </div>

  <div id="gameOverText" style="display: none">GAME OVER</div>
  <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/",
          "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
        }
      }
    </script>

  <script type="module">
    import * as THREE from "three";
    import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
    import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
    import * as CANNON from "cannon-es";

    // --- Setup Three.js ---
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(
      75,
      window.innerWidth / window.innerHeight,
      0.1,
      1000
    );
    // Puedes inicializarla aquí con una posición cercana a la esperada del avión,
    // o dejarla en (0,0,0) y que la lógica del `if` en animate la actualice en el primer frame.
    camera.position.set(0, 1.6, 3);
    const cameraOffset = new THREE.Vector3(0, 2, 6); // Se crea una sola vez

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Luces
    const light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5, 10, 7.5);
    scene.add(light);

    const ambient = new THREE.AmbientLight(0x404040);
    scene.add(ambient);

    // --- Setup Cannon-es (físicas) ---
    const world = new CANNON.World();
    world.gravity.set(0, -9, 0);

    const defaultMaterial = new CANNON.Material("default");
    const airplanePhysicsMaterial = new CANNON.Material("airplaneMaterial");

    const airplaneObstacleContactMaterial = new CANNON.ContactMaterial(
      airplanePhysicsMaterial,
      defaultMaterial,
      {
        friction: 0.1,
        restitution: 0.1,
      }
    );
    world.addContactMaterial(airplaneObstacleContactMaterial);


    let airplaneModel;
    let airplaneBody;
    let mixer = null;
    let action1, actionRotate;
    let gameOver = false;

    // Material para el avión para controlar fricción


    // Loaders
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath(
      "https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/libs/draco/gltf/"
    );
    dracoLoader.setDecoderConfig({ type: "js" });

    const loader = new GLTFLoader();
    loader.setDRACOLoader(dracoLoader);


    loader.load(
      "avion.glb",
      (gltf) => {
        airplaneModel = gltf.scene;
        airplaneModel.position.set(0, 1, 0);
        scene.add(airplaneModel);

        const boxShape = new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 1));
        airplaneBody = new CANNON.Body({
          mass: 1,
          shape: boxShape,
          material: airplanePhysicsMaterial,
          position: new CANNON.Vec3(
            airplaneModel.position.x,
            airplaneModel.position.y,
            airplaneModel.position.z
          ),
          linearDamping: 0.95, // Se mantiene el damping lineal
          angularDamping: 0.95, // <--- Este damping es crucial para que el giro se detenga
        });
        world.addBody(airplaneBody);

        console.log("¡Modelo de avión y cuerpo físico cargados!");

        if (gltf.animations && gltf.animations.length > 1) {
          mixer = new THREE.AnimationMixer(airplaneModel);
          actionRotate = mixer.clipAction(gltf.animations[0]);
          actionRotate.loop = THREE.LoopRepeat;
          actionRotate.clampWhenFinished = true;
          actionRotate.enabled = true;

          actionRotate.time = 2.475;
          actionRotate.play();
          actionRotate.paused = true;

          action1 = mixer.clipAction(gltf.animations[9]);
          action1.loop = THREE.LoopRepeat;
          action1.enabled = true;
          action1.play();
        }
      },
      undefined,
      (error) => {
        console.error("Error al cargar el modelo GLTF de avión:", error);
      }
    );

    loader.load(
      "escena.glb",
      (gltf) => {
        const sceneModel = gltf.scene;
        scene.add(sceneModel);

        sceneModel.traverse((child) => {
          if (child.isMesh && child.name.startsWith("colision")) {
            child.geometry.computeBoundingBox();
            const size = new THREE.Vector3();
            child.geometry.boundingBox.getSize(size);

            const obstacleShape = new CANNON.Box(
              new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2)
            );

            const obstacleBody = new CANNON.Body({
              mass: 0,
              shape: obstacleShape,
              material: defaultMaterial,
              position: new CANNON.Vec3(
                child.getWorldPosition(new THREE.Vector3()).x,
                child.getWorldPosition(new THREE.Vector3()).y,
                child.getWorldPosition(new THREE.Vector3()).z
              ),
            });
            world.addBody(obstacleBody);

            console.log(`Cuerpo físico estático creado para: ${child.name}`);
          }
        });

        console.log(
          "Modelo de escena y cuerpos físicos estáticos de Cannon.js cargados."
        );
      },
      undefined,
      (error) => {
        console.error("Error al cargar el modelo GLTF de escena:", error);
      }
    );

    world.addEventListener("beginContact", (event) => {
      const bodyA = event.bodyA;
      const bodyB = event.bodyB;

      if (
        (bodyA === airplaneBody && bodyB.mass === 0) ||
        (bodyB === airplaneBody && bodyA.mass === 0)
      ) {
        console.log("¡COLISIÓN DETECTADA POR CANNON.JS!");
        if (!gameOver) {
          gameOver = true;
          const gameOverText = document.getElementById("gameOverText");
          gameOverText.style.display = "block";

          if (mixer) {
            mixer.timeScale = 0;
          }
          joystickInput.strafe = 0;
          joystickInput.forward = 0;
          if (airplaneBody) {
            airplaneBody.velocity.set(0, 0, 0);
            airplaneBody.angularVelocity.set(0, 0, 0);
          }
        }
      }
    });

    // --- Control teclado ---
    const keys = {};
    window.addEventListener(
      "keydown",
      (e) => (keys[e.key.toLowerCase()] = true)
    );
    window.addEventListener(
      "keyup",
      (e) => (keys[e.key.toLowerCase()] = false)
    );



    // Variable global o en ámbito donde se mantenga entre frames
    let smoothedStrafe = 0;
    const threshold = 0.5; // Ajustá a lo que te guste

    function updateAnimationWithJoystick(strafe, action, deltaTime) {
      if (!action) return;

      const leftTime = 1.4;
      const rightTime = 3.65;
      // const centerTime = 2.475;

      const turnSpeed = 3;
      const returnSpeed = 5;

      // Si el strafe está dentro del umbral, tratarlo como 0

      if (Math.abs(strafe) < threshold) {
        strafe = 0;
      }

      const isReturning = Math.abs(strafe) < Math.abs(smoothedStrafe);
      const smoothingSpeed = isReturning ? returnSpeed : turnSpeed;

      smoothedStrafe +=
        (strafe - smoothedStrafe) * deltaTime * smoothingSpeed;

      // Normalización lineal (de -1 a 1) a tiempos
      const normalized = (smoothedStrafe + 1) / 2; // -1 → 0, 1 → 1
      const targetTime = leftTime + normalized * (rightTime - leftTime);

      if (!action.isRunning()) action.play();
      action.paused = true;

      action.time += (targetTime - action.time) * deltaTime * 5;
      action.setEffectiveWeight(1);
    }

    // --- Animación y física ---
    const clock = new THREE.Clock();


    const movementSpeed = 50; // Velocidad lineal máxima
    const rotationSpeed = 2; // Velocidad angular máxima para el giro

    //   const animStart = 1; // segundo inicio animación
    //   const animEnd = 5; // segundo fin animación
    //   let joystickActive = false;
    let strafeValue = 0;
    const fixedTimeStep = 1.0 / 60.0;
    const maxSubSteps = 3;

    const tempLocalForce = new CANNON.Vec3();
    const tempGlobalTorque = new CANNON.Vec3();
    const smoothedCameraPosition = new THREE.Vector3();
    function animate() {
      requestAnimationFrame(animate);

      const deltaTime = clock.getDelta();

      if (gameOver) {
        if (mixer) {
          mixer.update(deltaTime);
        }
        renderer.render(scene, camera);
        return;
      }

      if (airplaneBody) {
        // Coeficiente de resistencia aerodinámica (ajusta este valor)
        const arrastreCoefficient = 0.1;

        // Velocidad actual
        const velocity = airplaneBody.velocity;

        // Fuerza de arrastre = -velocidad * coeficiente
        const dragForce = velocity.scale(-arrastreCoefficient);

        // Aplica la fuerza de arrastre en el centro de masa
        airplaneBody.applyForce(dragForce, new CANNON.Vec3(0, 0, 0));
      }


      // Actualizar físicas
      world.step(fixedTimeStep, deltaTime, maxSubSteps);



      if (airplaneModel && airplaneBody) {
        // const forceSpeedMagnitude = 50;

        // const lateralForce = joystickInput.strafe *  forceSpeedMagnitude; // multiplicá para ajustar fuerza lateral
        // const forwardForce = -joystickInput.forward * forceSpeedMagnitude;
        // airplaneBody.applyLocalForce(
        //   new CANNON.Vec3(lateralForce, 0, forwardForce),
        //   new CANNON.Vec3(0, 0, 0)
        // );
        // airplaneModel.position.copy(airplaneBody.position);
        // airplaneModel.quaternion.copy(airplaneBody.quaternion);
             const forceForwardSpeedMagnitude = 2;
          const forceLateralSpeedMagnitude = 2;

        const lateralForce = joystickInput.strafe *  forceLateralSpeedMagnitude; // multiplicá para ajustar fuerza lateral
        const forwardForce = -joystickInput.forward * forceForwardSpeedMagnitude;
        // tempLocalForce.set(0, 0, forwardForce * movementSpeed);
        // airplaneBody.applyLocalForce(tempLocalForce, CANNON.Vec3.ZERO);
tempLocalForce.set(lateralForce * movementSpeed, 0, forwardForce * movementSpeed); 
airplaneBody.applyLocalForce(tempLocalForce, CANNON.Vec3.ZERO);

        


        // const targetAngularVelocityY = lateralForce * rotationSpeed;
        // airplaneBody.angularVelocity.y = targetAngularVelocityY;

        // if (Math.abs(lateralForce) < 0.1) {
        //   const currentVelocity = airplaneBody.velocity;

        //   const localVelocity = airplaneBody.quaternion.vmult(currentVelocity, new CANNON.Vec3());
        //   localVelocity.x *= 0.9; // Reduce lateral velocity
        //   airplaneBody.velocity.copy(airplaneBody.quaternion.vmult(localVelocity, new CANNON.Vec3(), true)); // true para invertir la rotación
        // }


        airplaneModel.position.copy(airplaneBody.position);
        airplaneModel.quaternion.copy(airplaneBody.quaternion);




        // const forwardForce = -joystickInput.forward; // Adelante/Atrás (Z)
        // const lateralForce = joystickInput.strafe; // Izquierda/Derecha (X)

        // tempLocalForce.set(0, 0, forwardForce * movementSpeed);
        // airplaneBody.applyLocalForce(tempLocalForce, CANNON.Vec3.ZERO);

        // const targetAngularVelocityY = lateralForce * rotationSpeed;
        // airplaneBody.angularVelocity.y = targetAngularVelocityY;

        // if (Math.abs(lateralForce) < 0.1) {
        //   const currentVelocity = airplaneBody.velocity;

        //   const localVelocity = airplaneBody.quaternion.vmult(currentVelocity, new CANNON.Vec3());
        //   localVelocity.x *= 0.9; // Reduce lateral velocity
        //   airplaneBody.velocity.copy(airplaneBody.quaternion.vmult(localVelocity, new CANNON.Vec3(), true)); // true para invertir la rotación
        // }

        // airplaneModel.position.copy(airplaneBody.position);
        // airplaneModel.quaternion.copy(airplaneBody.quaternion);

        // airplaneBody.applyLocalForce(
        //   new CANNON.Vec3(lateralForce, 0, forwardForce),
        //   new CANNON.Vec3(0, 0, 0)
        // );







        const antiGravity = new CANNON.Vec3(
          0,
          -world.gravity.y * airplaneBody.mass,
          0
        );
        airplaneBody.applyLocalForce(antiGravity, new CANNON.Vec3(0, 0, 0));

        // Actualizar posición y rotación del modelo con el cuerpo físico




        // --- Lógica de la cámara ---

        // const relativeCameraOffset = cameraOffset
        //             .clone()
        //             .applyQuaternion(airplaneModel.quaternion);
        //           // Posición objetivo donde queremos que esté la cámara
        //           const targetCameraPos = airplaneModel.position
        //             .clone()
        //             .add(relativeCameraOffset);
        //           if (smoothedCameraPosition.lengthSq() === 0) {
        //             smoothedCameraPosition.copy(targetCameraPos);
        //           }
        //           smoothedCameraPosition.lerp(targetCameraPos, 0.1); // <-- Ajusta este valor para más/menos suavizado
        //           // Actualizamos la posición de la cámara con la posición suavizada
        //           camera.position.copy(smoothedCameraPosition);

        //           // La cámara siempre mira al centro del modelo del avión
        //           camera.lookAt(airplaneModel.position);



        const relativeCameraOffset = cameraOffset
          .clone()
          .applyQuaternion(airplaneModel.quaternion);
        const targetCameraPos = airplaneModel.position
          .clone()
          .add(relativeCameraOffset);

        camera.position.copy(targetCameraPos);
        camera.lookAt(airplaneModel.position);
      }

      updateAnimationWithJoystick(
        joystickInput.strafe,
        actionRotate,
        deltaTime
      );

      if (mixer) {
        mixer.update(deltaTime);
      }

      // controls.update();
      renderer.render(scene, camera);
    }

    window.onload = animate;

    // --- Ajuste de ventana ---
    window.addEventListener("resize", () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
  <script src="./joystick.js"></script>
</body>

</html>