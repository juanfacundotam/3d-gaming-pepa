<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Three.js + Cannon-es con Joystick suave</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }

      canvas {
        display: block;
      }

      /* Joystick styles */
      #joystick {
        position: absolute;
        bottom: 35px;
        width: 80px;
        height: 80px;
        background: rgba(126, 126, 126, 0.5);
        border: #444 solid medium;
        border-radius: 50%;
        left: 50%;
        transform: translateX(-50%);
        z-index: 10;
        touch-action: none;
        user-select: none;
      }

      #thumb {
        position: absolute;
        left: 20px;
        top: 20px;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background: #fff;
      }
    </style>
  </head>

  <body>
    <div id="joystick">
      <div id="thumb"></div>
    </div>

    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js",
          "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/",
          "cannon-es": "https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/dist/cannon-es.js"
        }
      }
    </script>

    <script type="module">
      import * as THREE from "three";
      import { GLTFLoader } from "three/addons/loaders/GLTFLoader.js";
      import { DRACOLoader } from "three/addons/loaders/DRACOLoader.js";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import * as CANNON from "cannon-es";

      // --- Setup Three.js ---
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(0, 1.6, 3);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // OrbitControls
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 1, 0);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.maxPolarAngle = Math.PI / 2;

      // Luces
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 10, 7.5);
      scene.add(light);

      const ambient = new THREE.AmbientLight(0x404040);
      scene.add(ambient);

      // Suelo visual
      // const floorGeometry = new THREE.PlaneGeometry(100, 100);
      // const floorMaterial = new THREE.MeshStandardMaterial({
      //   color: 0x888888,
      //   roughness: 0.8,
      // });
      // const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      // floor.rotation.x = -Math.PI / 2;
      // floor.position.y = -1;
      // floor.receiveShadow = true;
      // scene.add(floor);

      // --- Setup Cannon-es (físicas) ---
      const world = new CANNON.World();
      world.gravity.set(0, -9, 0);
      const defaultMaterial = new CANNON.Material("defaultMaterial");
      world.defaultContactMaterial = new CANNON.ContactMaterial(
        defaultMaterial,
        defaultMaterial,
        {
          friction: 0.5, // Fricción entre los objetos
          restitution: 0.2, // Rebote (0 = sin rebote, 1 = rebote perfecto)
        }
      );
      // Suelo físico
      // const groundBody = new CANNON.Body({
      //   mass: 0, // estático
      //   shape: new CANNON.Plane(),
      //   material: new CANNON.Material({ friction: 0.5, restitution: 0.3 }),
      // });
      // groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0);
      // world.addBody(groundBody);

      // Material para el avión para controlar fricción
      const airplaneMaterial = new CANNON.Material({
        friction: 0.1,
        restitution: 0,
      });

      // --- Variables globales ---
      let model;
      let airplaneBody;
        const dynamicObjects = [];

      // Loaders
      const dracoLoader = new DRACOLoader();
      dracoLoader.setDecoderPath(
        "https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/libs/draco/gltf/"
      );
      dracoLoader.setDecoderConfig({ type: "js" });

      const loader = new GLTFLoader();
      loader.setDRACOLoader(dracoLoader);

      let mixer = null;
      let action1, actionRotate, actionRight, actionLeft;

      loader.load(
        "avion.glb",
        (gltf) => {
          model = gltf.scene;
          model.position.set(0, 1, 0);
          scene.add(model);

          // Crear cuerpo físico para el avión
          // Puedes ajustar tamaño según tu modelo
          const box = new CANNON.Box(new CANNON.Vec3(1, 0, 2));
          airplaneBody = new CANNON.Body({
            mass: 1,

            shape: box,
            material: airplaneMaterial,
            position: new CANNON.Vec3(0, 0, 0),
            linearDamping: 0.95, // para suavizar la velocidad
            angularDamping: 0.95, // para que no gire demasiado
          });
          world.addBody(airplaneBody);

          console.log("¡Modelo y físico cargados!");

          let playingW = false;
          let wTimer = null;
          const wDuration = 3; // segundos que querés que dure la animación 0

          // Al cargar el modelo:
          if (gltf.animations && gltf.animations.length > 1) {
            mixer = new THREE.AnimationMixer(model);
            actionRotate = mixer.clipAction(gltf.animations[0]);
            actionRotate.loop = THREE.LoopRepeat;
            actionRotate.clampWhenFinished = true;
            actionRotate.enabled = true;

            actionRotate.time = 2.475; // <-- Seteás el inicio en 1.4
            actionRotate.play();
            actionRotate.paused = true; // Si vas a manejar el tiempo manualmente

            // actionLeft = mixer.clipAction(gltf.animations[1]);
            // actionLeft.loop = THREE.LoopRepeat;
            // actionLeft.clampWhenFinished = true;
            // actionLeft.enabled = true;

            action1 = mixer.clipAction(gltf.animations[9]);
            action1.loop = THREE.LoopRepeat;
            action1.enabled = true;
            action1.play();
          }
        },
        undefined,
        (error) => {
          console.error("Error al cargar el modelo GLTF:", error);
        }
      );







 loader.load(
        "escena.glb",
        (gltf) => {
          model = gltf.scene;
          scene.add(model);
          console.log(model);
          // Buscar mesh con geometría para el piso
          // Buscar mesh con geometría para el piso
          const pisoMesh = getMeshByName(model, "piso");

          if (pisoMesh) {
            // **CAMBIO CLAVE 1: Usar CANNON.Plane para el piso físico**
            // Un CANNON.Plane es una superficie infinita. Por defecto, su normal apunta en el eje Y positivo.
            // Para que sea un piso horizontal (mirando hacia arriba), no necesita rotación especial si su normal ya es (0, 1, 0).
            // Sin embargo, si quieres que la parte visual del piso esté en Y=0 o donde esté tu piso en el GLTF,
            // asegúrate de que su posición física coincida.
            const pisoShape = new CANNON.Plane();

            const pisoBody = new CANNON.Body({
              mass: 0, // Masa 0 para un objeto estático (inmovible)
              shape: pisoShape,
              material: defaultMaterial,
              // La posición del piso físico debe coincidir con la del mesh.
              // Si tu piso en el GLTF está en Y=0, esta posición funcionará.
              position: new CANNON.Vec3(
                pisoMesh.getWorldPosition(new THREE.Vector3()).x,
                pisoMesh.getWorldPosition(new THREE.Vector3()).y,
                pisoMesh.getWorldPosition(new THREE.Vector3()).z
              ),
            });

            // **CAMBIO CLAVE 2: Rotar el CANNON.Plane para que sea horizontal**
            // Un CANNON.Plane por defecto es vertical (normal Y+). Para que sea un piso, debe rotarse.
            // Con esta rotación, la normal apunta hacia arriba (0, 1, 0)
            pisoBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // Rota 90 grados alrededor de X

            world.addBody(pisoBody);
            console.log(
              "Cuerpo físico creado para el piso usando CANNON.Plane"
            );
          } else {
            console.warn("No se encontró mesh con nombre 'piso'");
          }

          // Obstáculos colision_*
          model.traverse((child) => {
            if (child.isMesh && child.name.startsWith("colision")) {
              child.geometry.computeBoundingBox();
              const size = new THREE.Vector3();
              child.geometry.boundingBox.getSize(size);

              const shape = new CANNON.Box(
                new CANNON.Vec3(size.x / 2, size.y / 2, size.z / 2)
              );

              const body = new CANNON.Body({
                mass: 10, // Los obstáculos también suelen ser estáticos (masa 0)
                shape,
                material: defaultMaterial,
                position: new CANNON.Vec3(
                  child.getWorldPosition(new THREE.Vector3()).x,
                  child.getWorldPosition(new THREE.Vector3()).y,
                  child.getWorldPosition(new THREE.Vector3()).z
                ),
              });
              world.addBody(body);
              console.log(`Cuerpo físico creado para: ${child.name}`);
              dynamicObjects.push({ mesh: child, body: body });
            }
          });

          console.log(
            "Modelo y cuerpos físicos del piso y obstáculos cargados correctamente."
          );
        },
        undefined,
        (error) => {
          console.error("Error al cargar el modelo GLTF:", error);
        }
      );

      // Asegúrate de que esta función 'getMeshByName' esté definida UNA SOLA VEZ en tu código.
      // Si ya la tienes en otro lugar, elimina esta copia.
      function getMeshByName(model, name) {
        let foundMesh = null;
        model.traverse((child) => {
          if (child.isMesh && child.name === name) {
            foundMesh = child;
          }
        });
        return foundMesh;
      }








      // --- Control teclado ---
      const keys = {};
      window.addEventListener(
        "keydown",
        (e) => (keys[e.key.toLowerCase()] = true)
      );
      window.addEventListener(
        "keyup",
        (e) => (keys[e.key.toLowerCase()] = false)
      );

      let joystickActive = false;
      let previousStrafe = 0;
      let tiempoRight = 0;
      let tiempoLeft = 0;

      // Variable global o en ámbito donde se mantenga entre frames
      let smoothedStrafe = 0;
      const threshold = 0.5; // Ajustá a lo que te guste

      function updateAnimationWithJoystick(strafe, action, deltaTime) {
        if (!action) return;

        const leftTime = 1.4;
        const rightTime = 3.65;
        const centerTime = 2.475;

        const turnSpeed = 3;
        const returnSpeed = 5;

        // Si el strafe está dentro del umbral, tratarlo como 0
        console.log(Math.abs(strafe));
        if (Math.abs(strafe) < threshold) {
          strafe = 0;
        }

        const isReturning = Math.abs(strafe) < Math.abs(smoothedStrafe);
        const smoothingSpeed = isReturning ? returnSpeed : turnSpeed;

        smoothedStrafe +=
          (strafe - smoothedStrafe) * deltaTime * smoothingSpeed;

        // Normalización lineal (de -1 a 1) a tiempos
        const normalized = (smoothedStrafe + 1) / 2; // -1 → 0, 1 → 1
        const targetTime = leftTime + normalized * (rightTime - leftTime);

        if (!action.isRunning()) action.play();
        action.paused = true;

        action.time += (targetTime - action.time) * deltaTime * 5;
        action.setEffectiveWeight(1);
      }

      // --- Animación y física ---
      const clock = new THREE.Clock();
      const fixedTimeStep = 1.0 / 60.0;
      const maxSubSteps = 3;
      //   const animStart = 1; // segundo inicio animación
      //   const animEnd = 5; // segundo fin animación
      //   let joystickActive = false;
      let strafeValue = 0;
      function animate() {
        requestAnimationFrame(animate);
        if (airplaneBody) {
          // Coeficiente de resistencia aerodinámica (ajusta este valor)
          const arrastreCoefficient = 0.1;

          // Velocidad actual
          const velocity = airplaneBody.velocity;

          // Fuerza de arrastre = -velocidad * coeficiente
          const dragForce = velocity.scale(-arrastreCoefficient);

          // Aplica la fuerza de arrastre en el centro de masa
          airplaneBody.applyForce(dragForce, new CANNON.Vec3(0, 0, 0));
        }
        const deltaTime = clock.getDelta();

        // Actualizar físicas
        world.step(fixedTimeStep, deltaTime, maxSubSteps);
    dynamicObjects.forEach((obj) => {
          obj.mesh.position.copy(obj.body.position);
          obj.mesh.quaternion.copy(obj.body.quaternion);
        });

        if (model && airplaneBody) {
          const forceSpeedMagnitude = 50;

          const lateralForce = joystickInput.strafe * forceSpeedMagnitude; // multiplicá para ajustar fuerza lateral
          const forwardForce = -joystickInput.forward * forceSpeedMagnitude;

const antiGravity = new CANNON.Vec3(0, -world.gravity.y * airplaneBody.mass, 0);
airplaneBody.applyLocalForce(antiGravity, new CANNON.Vec3(0, 0, 0));


            airplaneBody.applyLocalForce(
            new CANNON.Vec3(lateralForce, 0, forwardForce),
            new CANNON.Vec3(0, 0, 0)
          );
          // Actualizar posición y rotación del modelo con el cuerpo físico
          model.position.copy(airplaneBody.position);
          model.quaternion.copy(airplaneBody.quaternion);
        }

        updateAnimationWithJoystick(
          joystickInput.strafe,
          actionRotate,
          deltaTime
        );

        if (mixer) {
          mixer.update(deltaTime);
        }

        controls.update();
        renderer.render(scene, camera);
      }

      window.onload = animate;

      // --- Ajuste de ventana ---
      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
    <script src="./joystick.js"></script>
  </body>
</html>
